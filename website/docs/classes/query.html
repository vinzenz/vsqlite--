<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>sqlite::query | vsqlite++ Reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../static/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  </head>
  <body>
    <div class="site-shell">
      <header class="site-header">
        <div class="brand">
          <h1>sqlite::query</h1>
          <span>SELECT wrapper returning sqlite::result</span>
        </div>
        <nav class="site-nav">
          <a href="../../">Overview</a>
          <a class="active" href="../../docs/">Documentation</a>
          <a href="../../community/">Community</a>
          <a href="https://github.com/vinzenz/vsqlite--">GitHub</a>
        </nav>
      </header>

      <main>
        <section class="doc-section">
          <p>
            Inherits from <a href="command.html"><code>sqlite::command</code></a>, but adds a range-based iteration API via
            <code>each()</code>. Bind values using <code>bind()</code> or <code>%</code>, then loop
            over <code>query.each()</code> with a range-based for to consume rows through the
            lightweight <code>row_view</code> proxy (supports column access by index or name).
          </p>
          <h2>Use cases</h2>
          <ul class="list">
            <li>Column-name lookups are cached per statement, so repeated <code>row["column"]</code>
              calls remain O(1).</li>
            <li><code>each()</code> is single-pass by design. Grab <code>get_result()</code> if you
              need to hold on to the cursor, rewind it, or interleave iteration with other work.</li>
            <li>The class enforces correct usage—attempting to iterate without finishing the
              previous <code>each()</code> will throw <code>database_misuse_exception</code>.</li>
          </ul>
        </section>

        <section class="doc-section">
          <h2>Public API</h2>
          <table class="reference-table">
            <tr><th>Member</th><th>Description</th></tr>
            <tr><td><code>query(connection&amp; con, std::string const&amp; sql)</code></td><td>Compiles the SELECT statement.</td></tr>
            <tr><td><code>query(query const&amp;)=delete</code>, <code>query&amp; operator=(query const&amp;)=delete</code></td><td>Non-copyable.</td></tr>
            <tr><td><code>~query()</code></td><td>Inherits <code>command</code>'s cleanup.</td></tr>
            <tr><td><code>result_range each()</code></td><td>Returns a single-pass range whose iterators yield <code>row_view</code> proxies for use in range-based for loops. Each proxy exposes <code>get&lt;T&gt;()</code> by index or name.</td></tr>
            <tr><td><code>result_type get_result()</code></td><td>Constructs a manual <a href="result.html"><code>sqlite::result</code></a> cursor for low-level access.</td></tr>
            <tr><td><code>result_type emit_result()</code> <em>(deprecated)</em></td><td>Legacy helper that executed the statement once; prefer <code>each()</code> or <code>get_result()</code>.</td></tr>
          </table>
          <p>
            <code>result_range</code> exposes an <code>iterator</code> type that models an
            input-iterator. Dereferencing yields a <code>row_view</code> proxy, letting you call
            <code>get&lt;T&gt;()</code> inside the loop.
          </p>
        </section>

        <section class="doc-section">
          <h2>Example usage</h2>
          <p>
            Stream rows with <code>each()</code>, optionally passing bind arguments inline, or grab
            <code>get_result()</code> when you need to pause iteration, rewind, or share the cursor
            with another consumer.
          </p>
<pre><code class="language-cpp">sqlite::query q(db, "SELECT id, text FROM notes WHERE project = ?");
for (auto &amp; row : q.each("docs")) {
    auto id = row.get&lt;std::int64_t&gt;("id");
    auto text = row.get&lt;std::string_view&gt;(1);
    fmt::print(\"[#{}] {}\\n\", id, text);
}</code></pre>
<pre><code class="language-cpp">sqlite::query filtered(db, "SELECT message FROM audit WHERE level = ? AND tag = ?");
filtered % "warn";
for (auto &amp; row : filtered.each("ui")) {
    log(row.get&lt;std::string&gt;(0));
}</code></pre>
<pre><code class="language-cpp">sqlite::query named_q(db, "SELECT body FROM notes WHERE project = :project");
for (auto &amp; row : named_q.each(sqlite::named(":project", "docs"))) {
    consume(row.get&lt;std::string&gt;(0));
}</code></pre>
<pre><code class="language-cpp">auto cursor = q.get_result();    // manual control
while (cursor-&gt;next_row()) {
    if (cursor-&gt;get_column_name(0) == \"id\") {
        // ...
    }
}</code></pre>
        </section>
      </main>

      <footer class="footer">
        Documentation for vsqlite++ 0.4.0 — header <code>include/sqlite/query.hpp</code>.
      </footer>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </body>
</html>
