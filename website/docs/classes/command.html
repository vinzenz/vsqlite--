<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>sqlite::command | vsqlite++ Reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../static/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  </head>
  <body>
    <div class="site-shell">
      <header class="site-header">
        <div class="brand">
          <h1>sqlite::command</h1>
          <span>Prepared statement base class</span>
        </div>
        <nav class="site-nav">
          <a href="../../">Overview</a>
          <a class="active" href="../../docs/">Documentation</a>
          <a href="../../community/">Community</a>
          <a href="https://github.com/vinzenz/vsqlite--">GitHub</a>
        </nav>
      </header>

      <main>
        <section class="doc-section">
          <p>
            <a href="command.html"><code>sqlite::command</code></a> owns a prepared statement (<code>sqlite3_stmt*</code>) and
            provides a uniform binding interface (<code>bind()</code> or operator <code>%</code>)
            for scalar, blob, optional, duration, and enum types. It is the base for higher-level
            helpers such as <a href="execute.html"><code>sqlite::execute</code></a> and <a href="query.html"><code>sqlite::query</code></a>.
          </p>
          <p>
            The helper <code>struct null_type</code> and the global <code>sqlite::nil</code> object
            are used to bind SQL NULLs via the streaming operator.
          </p>
          <h2>Use cases</h2>
          <ul class="list">
            <li>Designed for reuse—call <code>clear()</code> (or rely on <code>emit()</code> doing
              it) to keep the statement cached in the parent <code>connection</code>.</li>
            <li>Parameter indexes are 1-based like the native C API. The streaming operator keeps
              track of the next index so you can write expressive chaining code.</li>
            <li>Throws <code>database_exception_code</code> on prepare/bind/step errors and annotates
              messages with the SQL text for easier debugging.</li>
          </ul>
        </section>

        <section class="doc-section">
          <h2>Example usage</h2>
          <p>
            Variadic <code>operator()</code> binds whatever you pass and then executes, while still
            respecting any parameters you bound earlier via <code>operator%</code>.
          </p>
          <pre><code class="language-cpp">sqlite::command upsert{
    db,
    "INSERT INTO notes(id, text, edited_at) VALUES(?, ?, ?) "
    "ON CONFLICT(id) DO UPDATE SET text = excluded.text, edited_at = excluded.edited_at"
};

upsert % 42; // bind the id once
upsert(std::string_view{"Ship It"}, std::chrono::system_clock::now());

bool has_row = upsert.emit(); // true only when a row was returned (rare for INSERT)

if (!has_row) {
    upsert.clear(); // optional: prepares for the next round with new parameters
}</code></pre>
<pre><code class="language-cpp">sqlite::command audit{
    db,
    "INSERT INTO audit(entry, created_at) VALUES(?, ?)"
};

// All parameters bound via operator() in one go.
audit("created user", std::chrono::system_clock::now());</code></pre>
          <pre><code class="language-cpp">sqlite::command insert_named{
    db,
    "INSERT INTO metrics(name, value, created_at) VALUES(:name, @val, $created)"
};

insert_named % sqlite::named(":name", "uptime")
             % sqlite::named("@val", 42)
             % sqlite::named("$created", std::chrono::system_clock::now());

insert_named(sqlite::named(":name", "load"),
             sqlite::named("@val", 0.97),
             sqlite::named("$created", std::chrono::system_clock::now()));</code></pre>
          <p>
            If this pattern is only doing side-effect statements, swap it for
            <a href="execute.html"><code>sqlite::execute</code></a> and skip the manual lifetime juggling.
          </p>
        </section>

        <section class="doc-section">
          <h2>Lifecycle</h2>
          <table class="reference-table">
            <tr><th>Member</th><th>Description</th></tr>
            <tr>
              <td><code>command(connection&amp; con, std::string const&amp; sql)</code></td>
              <td>Compiles <code>sql</code> against <code>con</code> and prepares for binding.</td>
            </tr>
            <tr>
              <td><code>command(command const&amp;)=delete</code>, <code>command&amp; operator=(command const&amp;)=delete</code></td>
              <td>Statements cannot be copied because they own a unique <code>sqlite3_stmt*</code>.</td>
            </tr>
            <tr>
              <td><code>virtual ~command()</code></td>
              <td>Finalizes the prepared statement.</td>
            </tr>
            <tr>
              <td><code>void clear()</code></td>
              <td>Resets bindings so the statement can be reused.</td>
            </tr>
            <tr>
              <td><code>bool emit()</code>, <code>bool operator()()</code></td>
              <td>Executes the statement once. Returns <code>true</code> if SQLite signalled <code>SQLITE_ROW</code> (e.g., for UPDATE triggers).</td>
            </tr>
          </table>
        </section>

        <section class="doc-section">
          <h2>Binding API</h2>
          <table class="reference-table">
            <tr><th>Member</th><th>Description</th></tr>
            <tr><td><code>void bind(int idx)</code></td><td>Binds NULL to the 1-based parameter index.</td></tr>
            <tr><td><code>void bind(int idx, int value)</code></td><td>Binds a 32-bit integer.</td></tr>
            <tr><td><code>void bind(int idx, std::int64_t value)</code></td><td>Binds a 64-bit integer.</td></tr>
            <tr><td><code>void bind(int idx, double value)</code></td><td>Binds a floating-point value.</td></tr>
            <tr><td><code>template&lt;typename Text&gt; void bind(int idx, Text&amp;&amp; text)</code></td><td>Binds UTF-8 text from any type convertible to <code>std::string_view</code>.</td></tr>
            <tr><td><code>void bind(int idx, void const* buf, size_t size)</code></td><td>Binds a raw blob pointer.</td></tr>
            <tr><td><code>void bind(int idx, std::vector&lt;unsigned char&gt; const&amp;)</code></td><td>Binds a blob from a byte vector.</td></tr>
            <tr><td><code>void bind(int idx, std::span&lt;const unsigned char&gt;)</code></td><td>Binds a blob from a span of bytes.</td></tr>
            <tr><td><code>void bind(int idx, std::span&lt;const std::byte&gt;)</code></td><td>Binds a blob from a span of <code>std::byte</code>.</td></tr>
            <tr><td><code>template&lt;typename Value&gt; void bind_value(int idx, Value&amp;&amp;)</code></td><td>Dispatches to the correct overload for optionals, durations, time points, enums, integers, floating point numbers, strings, or blobs.</td></tr>
            <tr><td><code>template&lt;typename Value&gt; void bind(int idx, Value&amp;&amp;)</code></td><td>Calls <code>bind_value</code> when <code>Value</code> requires the generic path.</td></tr>
          </table>
          <p>
            Prefer named placeholders? wrap values with <code>sqlite::named(":placeholder", value)</code>
            and chain them through <code>operator%</code> or <code>operator()</code>; vsqlite++ resolves
            the parameter index under the hood.
          </p>
        </section>

        <section class="doc-section">
          <h2>Streaming operator (%)</h2>
          <p>
            Each overload increments an internal 1-based counter so you can write
            <code>cmd % 1 % "text" % sqlite::nil;</code> to bind arguments sequentially.
          </p>
          <table class="reference-table">
            <tr><th>Member</th><th>Description</th></tr>
            <tr><td><code>command&amp; operator%(null_type const&amp;)</code></td><td>Binds NULL.</td></tr>
            <tr><td><code>command&amp; operator%(int)</code></td><td>Binds 32-bit integer.</td></tr>
            <tr><td><code>command&amp; operator%(std::int64_t)</code></td><td>Binds 64-bit integer.</td></tr>
            <tr><td><code>command&amp; operator%(double)</code></td><td>Binds floating-point value.</td></tr>
            <tr><td><code>template&lt;typename Text&gt; command&amp; operator%(Text&amp;&amp;)</code></td><td>Binds text.</td></tr>
            <tr><td><code>command&amp; operator%(std::vector&lt;unsigned char&gt; const&amp;)</code></td><td>Binds blob.</td></tr>
            <tr><td><code>command&amp; operator%(std::span&lt;const unsigned char&gt;)</code>, <code>command&amp; operator%(std::span&lt;const std::byte&gt;)</code></td><td>Binds blob spans.</td></tr>
            <tr><td><code>template&lt;typename Value&gt; command&amp; operator%(Value&amp;&amp;)</code></td><td>Uses <code>bind_value</code> for optionals, durations, enums, etc.</td></tr>
          </table>
        </section>

        <section class="doc-section">
          <h2>Protected helpers</h2>
          <table class="reference-table">
            <tr><th>Member</th><th>Description</th></tr>
            <tr><td><code>void access_check()</code></td><td>Validates that the underlying statement is alive; throws on misuse.</td></tr>
            <tr><td><code>bool step()</code></td><td>Executes a single <code>sqlite3_step</code> call.</td></tr>
            <tr><td><code>sqlite3* get_handle()</code></td><td>Returns the raw database handle for advanced use cases.</td></tr>
          </table>
        </section>
      </main>

      <footer class="footer">
        Documentation for vsqlite++ 0.4.0 — header <code>include/sqlite/command.hpp</code>.
      </footer>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </body>
</html>
